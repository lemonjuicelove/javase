关于线程的调度（了解内容）

1、1 常见的线程调度模型有哪些：
        抢占式调度模型：
            哪个线程的优先级高，抢到的CPU时间片的概率就高一些，java采用的就是抢占式调度模型

        均分式调度模型：
            平均分配CPU时间片，每个线程占有的CPU时间片时间长度一样

1、2 java中提供了哪些方法是和线程调度有关的：
        实例方法：
            void setPriority(int newPriority) 设置线程的优先级
            int getPriority() 获取线程优先级
            最低优先级是1，默认优先级是5，最高优先级是10

        静态方法：
            static void yield() 让位方法
            暂停当前正在执行的线程对象，并执行其他线程
            yield()方法不是阻塞方法，会让当前线程从"运行状态"回到"就绪状态"
            注意：在回到就绪之后，有可能还会再次抢到

        实例方法：
            void join() 合并线程

            class MyThread1 extend Thread{
                public void doSome(){
                    MyThread2 mt = new MyThread2();
                    mt.join(); // 当前线程进入阻塞，mt线程执行，直到mt线程结束，当前线程才可以继续执行
                               // 相当于从多线程变成了单线程
                }
            }
            class MyThread2 extends Thread{
            }


关于多线程并发环境下，数据的安全问题

2、1 什么时候数据在多线程并发的环境下会存在安全问题
        条件1：多线程并发
        条件2：有共享数据
        条件3：共享数据有修改的行为
     满足以上3个条件之后，就会存在线程安全问题

2、2 怎么解决线程安全问题：
        当多线程并发的环境下，有共享数据，并且这个数据还会被修改，此时就存在线程安全问题，如何解决：
            线程排队执行 (不能并发)
            用排队执行解决线程安全问题，这种机制被称为：线程同步机制

        线程同步就是线程排队执行，线程排队执行就会牺牲一部分效率，但是数据安全第一位，
        只有数据安全了，才可以谈效率，数据不安全，效率没有意义

2、3 同步和异步：
        异步编程模型：
            线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，谁也不需要等谁，
            这种编程模型叫做：异步编程模型。其实就是：多线程并发(效率较高)

            异步就是并发

        同步编程模型：
            线程t1和线程t2，在线程t1执行的时候，必须等待线程t2执行结束，或者线程t2
            执行的时候，必须等待线程t1执行结束。两个线程之间发生了等待关系，这就是
            同步编程模型。效率较低，线程排队执行

            同步就是排队


Java中的三大变量：

    实例变量：在堆中
    静态变量：在方法区中
    局部变量：在栈中

    以上三大变量中：局部变量永远都不会存在线程安全问题。因为局部变量在栈中，所以局部变量永远都不会共享(一个线程一个栈)

    实例变量在堆中，堆只有一个；静态变量在方法区中，方法区只有一个
    堆和方法区都是多线程共享的，所以可能存在线程安全问题

    局部变量+常量：不会有线程安全问题
    成员变量：可能会有线程安全问题


总结：synchronized有三种写法：

        第一种：同步代码块
            synchronized(线程共享对象){
                同步代码块;
            }

        第二种：在实例方法上使用synchronized
            表示找对象锁
            表示共享对象一定是this，并且同步代码块是整个方法体

        第三种：在静态方法上使用synchronized
            表示找类锁
            类锁永远只有1把，就算创建了100个对象，类锁也只有一把

        对象锁：1个对象1把锁，100个对象100把锁
        类锁：100个对象也只有1把类锁
        对象锁和类锁不相同，一个找对象锁，一个找类锁时，不会排队执行


以后在开发中如何解决线程安全问题：
    在以后开发中，并不是一上来就选择线程同步机制，synchronized会让程序的执行效率降低，用户体验差，
    系统的用户吞吐量降低，在不得已的情况下再选择线程同步机制

    方案1：尽量使用局部变量来代替实例变量和静态变量

    方案2：如果必须是实例变量，那么可以考虑创建多个对象，这样实例变量的内存就不共享了，一个线程对应
          一个对象，100个线程对应100个对象，对象不共享，就没有数据安全问题

    方案3：如果不能使用局部变量，也不能创建多个对象，这个时候就只能选择synchronized，线程同步机制


线程还有哪些内容：

    1、守护线程
        java语言中线程可分为两大类：
            一类是：用户线程
            一类是：守护线程(后台线程)
            其中具有代表性的是：垃圾回收线程(守护线程)

        守护线程的特点：
            一般守护线程是一个死循环，所有的用户线程只要结束，守护线程自动结束

        注意：主线程main方法是一个用户线程

    2、定时器
        定时器的作用:间隔特定的时间，执行特定的程序

        在实际的开发中，每隔多久执行一段特定的程序，这周需求是很常见的，在java中可以采用多种方式实现：
            可以使用sleep方法，设置睡眠时间，到点醒来，执行任务，这种方式是最原始的定时器

            在java类库中已经写好了一个定时器：java.util.Timer，可以直接拿来用。不过这种方式在开发中也很少用，
            因为现在很多高级框架都是支持定时任务的

            在实际的开发中，目前使用较多的是Spring框架中提供的SpringTask框架，这个框架只需要进行简单的配置，
            就可以完成定时器任务

    3、实现线程的第三种方式：FutureTask方式，实现Callable接口

    4、关于Object类中的wait和notify方法。(生产者和消费者模式)

        第一：wait和notify方法不是线程对象的方法，是java中任何一个java对象都有的方法，因为这两个方法是Object类中自带的
                wait方法和notify方法不是通过线程对象调用的

        第二：wait方法作用：
                Object o = new Object();
                o.wait();

                表示：让正在o对象上活动的线程进入等待状态，直到唤醒为止
                     会让当前线程进入等待状态

        第三：notify方法作用：
                Object o = new Object();
                o.notify();

                表示：唤醒正在o对象上等待的线程

                还要一个notifyAll()方法：唤醒正在o对象上处于等待的所有线程